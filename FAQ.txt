FAQ – Garden Guardian (Python Error Handling)

=============================================

Este archivo recoge dudas habituales y explicaciones conceptuales
relacionadas con el módulo Garden Guardian.

NO forma parte del proyecto a entregar.
Sirve como apoyo personal para el aprendizaje, la revisión y la defensa.

1) ¿Por qué el programa no debe crashear nunca?

Porque el objetivo del módulo es aprender a manejar errores de forma controlada.
Un programa robusto no evita todos los fallos: los detecta, los gestiona y
continúa su ejecución sin detenerse.

Idea clave:
“Robusto” no significa “nunca falla”, sino “sabe recuperarse”.

2) ¿Qué significa “separación de responsabilidades” en este módulo?

Significa que cada función debe encargarse de una sola tarea concreta.

Ejemplo habitual:

Una función valida datos y devuelve un resultado o lanza un error.

Otra función (tests / main) se encarga del output y de demostrar
que el programa continúa ejecutándose.

Ventajas:

Código más claro

Funciones reutilizables

Más fácil de testear y defender

3) ¿Por qué una función debe devolver valores en lugar de imprimirlos?

Porque devolver valores permite reutilizar la función en otros contextos.
Además, el enunciado suele pedir explícitamente return, no print.

Idea clave:
Devolver datos ≠ mostrar datos.

4) ¿Cuándo tiene sentido imprimir directamente en una función?

Solo cuando la función representa una acción final (scripts muy simples).
En este módulo, la mayoría de funciones representan lógica, no presentación.

Regla práctica:

Lógica → devuelve valores o lanza errores

Tests / main → imprimen

5) ¿Por qué usar try/except en lugar de comprobar todo con if?

Porque hay errores que no se pueden detectar solo con if, como cuando una
cadena no se puede convertir a número. En esos casos Python lanza una excepción.

Idea clave:
try/except se usa para errores de ejecución, no para lógica normal.

6) ¿Qué ocurre cuando hago int("abc")?

Python lanza un ValueError porque "abc" no es un número válido.
Si no se captura, el programa se detiene.
Si se captura, el programa puede informar del error y continuar.

7) ¿Por qué lanzar errores (raise) en lugar de imprimirlos directamente?

Porque lanzar errores permite separar:

detección del problema (raise)

decisión de qué hacer (except)

Esto hace el diseño más limpio, flexible y escalable.

Idea clave:
raise señala el problema; except decide la reacción.

8) ¿Qué aporta raise frente a devolver False o None?

raise interrumpe el flujo normal y obliga a gestionar el error.
Esto evita que el programa continúe con datos inválidos.

En EX4, raise se usa para:

detener la ejecución cuando los datos no cumplen las reglas

centralizar la validación en una sola función

9) ¿Por qué el mensaje de error debe ser claro y específico?

Porque el objetivo no es solo evitar el crash, sino facilitar la comprensión
de qué ha fallado y por qué.

Un buen mensaje de error:

indica el valor problemático

explica el motivo

menciona la regla o el rango esperado

10) ¿Por qué es importante respetar el output del ejemplo?

Porque en ejercicios evaluados el formato del output puede formar parte de la
validación. Saltos de línea, espacios y textos deben coincidir exactamente.

Consejo práctico:
Controlar el formato con print() explícitos, no con "\n" incrustados.

11) ¿Qué aporta finally frente a try/except?

finally se ejecuta siempre, haya ocurrido un error o no.
Se utiliza para garantizar acciones de cierre o limpieza.

Idea clave:
finally = “cleanup garantizado”.

12) ¿Por qué finally se ejecuta incluso si hay return?

Porque finally tiene prioridad sobre el flujo normal.
Python garantiza que finally se ejecuta antes de salir de la función,
independientemente de return o excepción.

13) ¿Tiene sentido usar finally si ya capturo el error con except?

Sí.

except gestiona el error.

finally garantiza que ciertas acciones se ejecutan siempre.

Son responsabilidades distintas.

14) ¿Por qué en EX3 se devuelve True o False?

Para permitir que la función que llama decida qué hacer:

mostrar éxito

mostrar mensaje final

tomar decisiones según el resultado

Esto refuerza la separación entre lógica y presentación.

15) ¿Por qué no capturar Exception genérico?

Porque capturar Exception puede ocultar errores inesperados.
Es mejor capturar solo las excepciones que sabes manejar.

Buena práctica:
capturar lo específico, no lo genérico.

16) ¿Por qué validar explícitamente plant is None o plant == ""?

Porque el subject define ese caso como inválido.
Validarlo directamente:

hace el error más claro

evita errores indirectos

mejora la coherencia del mensaje

17) ¿Cuándo tiene sentido crear errores personalizados?

Cuando los errores genéricos no expresan bien el contexto del problema.

En EX2, los errores personalizados:

hacen el código más expresivo

permiten agrupar errores por dominio

facilitan la captura general con una clase base

18) ¿Qué significa “Keep solutions simple” en este módulo?

Significa priorizar:

claridad

pocas líneas bien pensadas

nombres comprensibles

funciones pequeñas

evitar sobre-ingeniería

Un código simple y explicable es más defendible.

19) ¿Qué significa “Authorized” en el enunciado?

Indica los conceptos mínimos que se espera que utilices.
No suele ser una lista cerrada de prohibiciones, salvo que se indique.

Regla práctica:

No usar librerías externas

No evitar el objetivo del ejercicio

Usar built-ins con sentido

20) ¿Está bien usar enumerate aunque no aparezca en “Authorized”?

Sí, si se usa como apoyo al control del bucle o del formato.
enumerate es una función built-in y mejora la claridad.

Idea clave:
enumerate ayuda al control del flujo, no sustituye try/except.

21) ¿Por qué el mensaje de “cleanup” se imprime incluso con error?

Porque finally se ejecuta siempre.
Ese es exactamente el concepto que se evalúa en EX3.

22) ¿Qué esperan en la defensa del proyecto?

Que puedas:

explicar qué error ocurre en cada caso

justificar try / except / finally / raise

describir el flujo cuando algo falla

razonar decisiones de diseño

demostrar que el programa se recupera

23) ¿Cómo explico finally en una frase?

“Uso finally para garantizar que las tareas de limpieza se ejecutan siempre,
independientemente de si el proceso termina con éxito o con error.”

