FAQ – Garden Guardian (Python Error Handling)
=============================================

Este archivo recoge dudas habituales y explicaciones conceptuales
relacionadas con el módulo Garden Guardian.

NO forma parte del proyecto a entregar.
Sirve como apoyo personal para el aprendizaje, la revisión y la defensa.


------------------------------------------------------------
1) ¿Por qué el programa no debe crashear nunca?
------------------------------------------------------------
Porque el objetivo del módulo es aprender a manejar errores de forma controlada.
Un programa robusto no evita todos los fallos: los detecta, los gestiona y
continúa su ejecución sin detenerse.

Idea clave:
“Robusto” no significa “nunca falla”, sino “sabe recuperarse”.


------------------------------------------------------------
2) ¿Qué significa “separación de responsabilidades” en este módulo?
------------------------------------------------------------
Significa que cada función debe encargarse de una sola tarea concreta.

Ejemplo habitual:
- Una función valida datos y devuelve un resultado o lanza un error.
- Otra función (tests / main) se encarga de los prints y de demostrar
  que el programa continúa ejecutándose.

Ventajas:
- Código más claro
- Funciones reutilizables
- Más fácil de testear y defender


------------------------------------------------------------
3) ¿Por qué check_temperature devuelve un valor en lugar de imprimirlo?
------------------------------------------------------------
Porque el enunciado pide explícitamente “Returns the temperature if it’s valid”.
Devolver valores permite reutilizar la función en otros contextos sin depender
de la salida por pantalla (por ejemplo, en ejercicios posteriores).

Idea clave:
Devolver datos ≠ mostrar datos.


------------------------------------------------------------
4) ¿Por qué usar try/except en lugar de comprobar todo con if?
------------------------------------------------------------
Porque hay errores que no se pueden detectar solo con if, como cuando una cadena
no puede convertirse a número. En esos casos Python lanza una excepción
(ValueError), y la forma correcta de manejarla es con try/except.

Idea clave:
try/except se usa para errores de ejecución, no para lógica normal.


------------------------------------------------------------
5) ¿Qué ocurre cuando hago int("abc")?
------------------------------------------------------------
Python lanza un ValueError porque "abc" no representa un número válido.
Si no se captura, el programa se detiene. Si se captura, se puede mostrar un
mensaje claro y continuar con la ejecución del resto del programa.


------------------------------------------------------------
6) ¿Por qué lanzar errores (raise) en lugar de imprimirlos directamente?
------------------------------------------------------------
Porque lanzar errores permite que otra parte del programa decida cómo actuar:
- mostrar un mensaje
- probar otra opción
- registrar el fallo
- continuar con otros datos

Esto hace el diseño más flexible, limpio y escalable.


------------------------------------------------------------
7) ¿Por qué el mensaje de error debe ser claro y específico?
------------------------------------------------------------
Porque el objetivo no es solo evitar el crash, sino facilitar la comprensión
de qué ha fallado y por qué.

Un buen mensaje de error:
- indica el valor problemático
- explica el motivo del fallo
- menciona la regla o rango esperado


------------------------------------------------------------
8) ¿Por qué es importante respetar el output del ejemplo?
------------------------------------------------------------
Porque en ejercicios evaluados el formato del output puede formar parte de la
validación. Saltos de línea, espacios y texto deben coincidir con el ejemplo.

Consejo práctico:
Controlar el formato con print() explícitos, no con “\n” incrustados en los textos.


------------------------------------------------------------
9) ¿Qué aporta finally frente a try/except?
------------------------------------------------------------
finally se ejecuta siempre, haya ocurrido un error o no.
Se utiliza para garantizar acciones de cierre o limpieza, como:
- cerrar recursos
- finalizar procesos simulados
- dejar el programa en un estado consistente

Idea clave:
finally = “cleanup garantizado”.


------------------------------------------------------------
10) ¿Cuándo tiene sentido crear errores personalizados?
------------------------------------------------------------
Cuando los errores genéricos de Python no expresan bien el contexto del problema.
En sistemas con dominio concreto (huerto, sensores, agricultura), los errores
personalizados:
- hacen el código más expresivo
- facilitan el manejo por tipo
- permiten agruparlos mediante herencia

Idea clave:
Herencia para organizar familias de errores.


------------------------------------------------------------
11) ¿Qué significa “Keep solutions simple” en este módulo?
------------------------------------------------------------
Significa priorizar:
- claridad
- pocas líneas bien pensadas
- nombres comprensibles
- funciones pequeñas
- evitar sobre-ingeniería

Un código simple y bien explicado suele ser más valorado que uno complejo
difícil de justificar.


------------------------------------------------------------
12) ¿Qué esperan en la defensa del proyecto?
------------------------------------------------------------
Que puedas:
- explicar qué tipo de error ocurre en cada caso (ValueError, KeyError…)
- justificar el uso de try/except/finally
- describir el flujo del programa cuando ocurre un fallo
- razonar tus decisiones de diseño
- demostrar que el programa se recupera y continúa


------------------------------------------------------------
13) ¿Qué significa “Authorized” en el enunciado?
------------------------------------------------------------
Indica los conceptos y herramientas mínimas que se espera que utilices.
No suele ser una lista cerrada de prohibiciones, salvo que el subject lo indique
explícitamente.

Regla práctica:
- No usar librerías externas
- No evitar el objetivo del ejercicio
- Usar built-ins de Python con sentido y claridad


------------------------------------------------------------
14) ¿Está bien usar enumerate aunque no aparezca en “Authorized”?
------------------------------------------------------------
Sí, siempre que se use como apoyo al control del bucle o al formato del output,
y no para evitar lo que se está evaluando.

enumerate es una función built-in y ayuda a escribir código más claro.
Ejemplo típico: controlar saltos de línea entre tests sin añadir líneas extra.

Idea clave:
enumerate mejora el control del flujo, no sustituye el manejo de errores.

