FAQ – Garden Guardian (Python Error Handling)
============================================

Este archivo recoge dudas habituales y explicaciones conceptuales
relacionadas con el módulo Garden Guardian.

NO forma parte del proyecto a entregar.
Sirve como apoyo personal para el aprendizaje, la revisión y la defensa.

------------------------------------------------------------
1) ¿Por qué el programa no debe crashear nunca?
------------------------------------------------------------
Porque el objetivo del módulo es aprender a manejar errores de forma controlada.
Un programa robusto no evita todos los fallos: los detecta, los gestiona y
continúa funcionando sin detenerse.

Idea clave: “Robusto” = “se recupera”, no “nunca falla”.


------------------------------------------------------------
2) ¿Qué significa “separación de responsabilidades” en este módulo?
------------------------------------------------------------
Significa que cada función debería encargarse de una sola cosa.

Ejemplo típico:
- Una función valida datos y devuelve un resultado (o lanza un error).
- Otra función (tests / main) decide cómo mostrar mensajes (prints) y
  demuestra que el programa sigue ejecutándose.

Ventaja: el código es más reutilizable, más fácil de testear y más defendible.


------------------------------------------------------------
3) ¿Por qué check_temperature devuelve un valor en lugar de imprimirlo?
------------------------------------------------------------
Porque el enunciado pide explícitamente “Returns the temperature if it’s valid”.
Devolver un valor permite reutilizar esa función en otros contextos sin depender
de mensajes por pantalla (por ejemplo, en un sistema mayor como el EX5).

Idea clave: devolver datos ≠ mostrar datos.


------------------------------------------------------------
4) ¿Por qué usar try/except en lugar de comprobar todo con if?
------------------------------------------------------------
Porque hay errores que no se detectan solo con if, como cuando una cadena no se
puede convertir a número. En esos casos, Python lanza una excepción (ValueError)
y la forma correcta de gestionarlo es capturarla con try/except.

Try/except es la herramienta para “errores de ejecución”, no para lógica normal.


------------------------------------------------------------
5) ¿Qué ocurre cuando hago int("abc")?
------------------------------------------------------------
Python lanza ValueError porque "abc" no es un número válido.
Si no se captura, el programa se detiene. Si se captura, se puede mostrar un
mensaje claro y seguir ejecutando el resto del programa.


------------------------------------------------------------
6) ¿Por qué lanzar errores (raise) en lugar de imprimirlos directamente?
------------------------------------------------------------
Porque lanzar errores permite que otra parte del programa decida qué hacer:
- mostrar un mensaje
- probar otra opción
- registrar el fallo
- continuar con otros datos

Esto hace el diseño más flexible y escalable.


------------------------------------------------------------
7) ¿Por qué el mensaje de error debe ser claro y específico?
------------------------------------------------------------
Porque el objetivo no es solo “que no crashee”, sino que sea fácil entender
qué falló y por qué. Un buen mensaje reduce tiempo de depuración y ayuda a
quien usa el programa a corregir la entrada.

Un buen error:
- indica el valor problemático
- dice el motivo
- da el rango o regla esperada


------------------------------------------------------------
8) ¿Por qué es importante respetar el output del ejemplo?
------------------------------------------------------------
Porque el formato del output puede formar parte de la validación.
Saltos de línea, espacios y texto deben coincidir con el ejemplo para evitar
errores en evaluación o confusiones al revisar.

Consejo: controlar el formato con prints explícitos, no con “\n” por todas partes.


------------------------------------------------------------
9) ¿Qué aporta finally frente a try/except?
------------------------------------------------------------
finally se ejecuta siempre, ocurra o no un error.
Sirve para “limpiar” y dejar el sistema en un estado seguro:
- cerrar recursos
- “apagar” un sistema simulado
- garantizar mensajes de cierre
- evitar que el programa quede a medias

Idea clave: finally = “cleanup garantizado”.


------------------------------------------------------------
10) ¿Cuándo tiene sentido crear errores personalizados?
------------------------------------------------------------
Cuando los errores genéricos no expresan bien el contexto del problema.
En sistemas con dominio (jardín / sensores / agricultura), errores específicos:
- hacen el código más expresivo
- facilitan el manejo por tipo
- permiten agruparlos con herencia (GardenError -> PlantError/WaterError)

Idea clave: herencia para organizar familias de errores.


------------------------------------------------------------
11) ¿Qué significa “Keep solutions simple” en este módulo?
------------------------------------------------------------
Significa priorizar:
- claridad
- pocas líneas bien pensadas
- nombres comprensibles
- funciones pequeñas
- evitar sobre-ingeniería

Un código simple y explicable suele ser más valorado que uno “muy listo”.


------------------------------------------------------------
12) ¿Qué esperan en la defensa del proyecto?
------------------------------------------------------------
Que puedas:
- explicar qué tipo de error ocurre en cada caso (ValueError, KeyError…)
- justificar por qué usas try/except/finally
- demostrar que entiendes el flujo cuando algo falla
- razonar decisiones (por qué devuelves valores, por qué lanzas errores, etc.)
- mostrar que tu programa se recupera y continúa


------------------------------------------------------------
13) ¿Qué significa “Authorized” en el enunciado?
------------------------------------------------------------
Normalmente indica las herramientas mínimas/conceptos que se esperan para
resolver el ejercicio (lo que se quiere practicar).
No suele ser una “lista cerrada” de prohibiciones, salvo que el enunciado lo diga
explícitamente.

Regla práctica:
- No uses librerías externas ni “trucos” que eviten el objetivo del ejercicio.
- Usa herramientas estándar de Python con sentido (built-ins).


------------------------------------------------------------
14) ¿Está bien usar enumerate aunque no aparezca en “Authorized”?
------------------------------------------------------------
Sí, si se usa para control de bucle/formato y no para evitar lo que se evalúa.
enumerate es una función built-in y ayuda a escribir código más claro.
Ejemplo típico: controlar saltos de línea entre tests sin añadir líneas extra al final.

Idea clave: enumerate mejora el control del flujo, no sustituye try/except.

